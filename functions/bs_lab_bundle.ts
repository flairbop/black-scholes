export const BS_LAB_FILES = {
  "core.py": "import math\n\ndef norm_pdf(x):\n    \"\"\"Standard normal probability density function.\"\"\"\n    return math.exp(-0.5 * x * x) / math.sqrt(2 * math.pi)\n\ndef norm_cdf(x):\n    \"\"\"Standard normal cumulative distribution function (Abramowitz & Stegun).\"\"\"\n    # Use erf for standard implementation in Python math\n    return 0.5 * (1 + math.erf(x / math.sqrt(2.0)))\n\ndef d1_d2(S, K, T, r, q, sigma):\n    \"\"\"Computes d1 and d2 terms for Black-Scholes.\"\"\"\n    if T <= 0 or sigma <= 0:\n        return 0.0, 0.0\n        \n    sqrt_T = math.sqrt(T)\n    # math.log(S/K) handles positive S, K. Checked in caller.\n    d1 = (math.log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * sqrt_T)\n    d2 = d1 - sigma * sqrt_T\n    return d1, d2\n\ndef bs_price(S, K, T, r, q, sigma, option_type=\"call\"):\n    \"\"\"Computes Black-Scholes price for call or put.\"\"\"\n    # Boundary / Limits\n    if S <= 0 or K <= 0: return 0.0\n    if T <= 0:\n        return max(0.0, S - K) if option_type == \"call\" else max(0.0, K - S)\n    if sigma < 1e-9:\n        # Intrinsic approx (discounted)\n        fwd = S * math.exp((r-q)*T)\n        val = max(0.0, fwd - K) if option_type == \"call\" else max(0.0, K - fwd)\n        return val * math.exp(-r*T)\n\n    d1, d2 = d1_d2(S, K, T, r, q, sigma)\n    \n    if option_type == \"call\":\n        price = S * math.exp(-q * T) * norm_cdf(d1) - K * math.exp(-r * T) * norm_cdf(d2)\n    else:\n        price = K * math.exp(-r * T) * norm_cdf(-d2) - S * math.exp(-q * T) * norm_cdf(-d1)\n        \n    return max(0.0, price)\n",
  "greeks.py": "import math\nfrom .core import d1_d2, norm_pdf, norm_cdf\n\ndef bs_greeks(S, K, T, r, q, sigma, option_type=\"call\"):\n    \"\"\"Computes Delta, Gamma, Vega, Theta, Rho.\"\"\"\n    if T <= 0:\n        return {\n            \"delta\": 0.0, \"gamma\": 0.0, \"vega\": 0.0, \"theta\": 0.0, \"rho\": 0.0\n        }\n    \n    # Validation/Clamp\n    if sigma < 1e-9: sigma = 1e-9\n    \n    d1, d2 = d1_d2(S, K, T, r, q, sigma)\n    # nd1 = N'(d1)\n    nd1 = norm_pdf(d1)\n    \n    exp_qT = math.exp(-q * T)\n    exp_rT = math.exp(-r * T)\n    sqrt_T = math.sqrt(T)\n    \n    # Gamma (same for call/put)\n    gamma = (exp_qT * nd1) / (S * sigma * sqrt_T)\n    \n    # Vega (raw derivative dV/dSigma). Same for call/put.\n    vega = S * exp_qT * nd1 * sqrt_T\n    \n    if option_type == \"call\":\n        # Delta\n        delta = exp_qT * norm_cdf(d1)\n        \n        # Rho (dV/dr)\n        rho = K * T * exp_rT * norm_cdf(d2)\n        \n        # Theta (dV/dt, usually negative)\n        # Term 1\n        t1 = - (S * exp_qT * nd1 * sigma) / (2 * sqrt_T)\n        # Term 2\n        t2 = - r * K * exp_rT * norm_cdf(d2)\n        # Term 3\n        t3 = q * S * exp_qT * norm_cdf(d1)\n        theta = t1 + t2 + t3\n        \n    else: # put\n        # Delta\n        delta = -exp_qT * norm_cdf(-d1)\n        \n        # Rho\n        rho = -K * T * exp_rT * norm_cdf(-d2)\n        \n        # Theta\n        t1 = - (S * exp_qT * nd1 * sigma) / (2 * sqrt_T)\n        t2 = r * K * exp_rT * norm_cdf(-d2)\n        t3 = - q * S * exp_qT * norm_cdf(-d1)\n        theta = t1 + t2 + t3\n    \n    # Return RAW values. API/Formatting layer handles scaling (e.g. /100, /365).\n    # Maintain numerical purity here.\n    return {\n        \"delta\": delta,\n        \"gamma\": gamma,\n        \"vega\": vega,\n        \"theta\": theta,\n        \"rho\": rho\n    }\n",
  "iv.py": "from .core import bs_price\nfrom .greeks import bs_greeks\nimport math\n\nERROR_ARBITRAGE = \"Arbitrage violation: Price out of bounds\"\n\ndef implied_volatility(market_price, S, K, T, r, q, option_type=\"call\"):\n    \"\"\"\n    Computes implied volatility using bisection method.\n    Metrics: sigma in [1e-6, 5.0]\n    \"\"\"\n    # 0. Pre-checks\n    if T <= 0:\n        return {\"iv\": 0.0, \"status\": \"expired\"}\n    if market_price <= 0:\n        return {\"iv\": None, \"status\": \"invalid_price\"}\n    \n    # 1. Arbitrage Bounds\n    exp_rT = math.exp(-r * T)\n    exp_qT = math.exp(-q * T)\n    \n    if option_type == \"call\":\n        # Lower bound: Intrinsic value (discounted S - discounted K)\n        # Upper bound: Stock price (discounted)\n        lower_bound = max(0.0, S * exp_qT - K * exp_rT)\n        upper_bound = S * exp_qT\n    else:\n        # Lower bound: Intrinsic value\n        # Upper bound: Strike price (discounted)\n        lower_bound = max(0.0, K * exp_rT - S * exp_qT)\n        upper_bound = K * exp_rT\n    \n    # Allow small epsilon tolerance for float errors\n    epsilon = 1e-7\n    if market_price < lower_bound - epsilon or market_price > upper_bound + epsilon:\n        return {\"iv\": None, \"status\": ERROR_ARBITRAGE, \"bounds\": (lower_bound, upper_bound)}\n        \n    # If price is at lower bound (intrinsic), IV is 0 defined limit.\n    if abs(market_price - lower_bound) < epsilon:\n        return {\"iv\": 0.0, \"status\": \"intrinsic\"}\n        \n    # 2. Bisection Solver\n    low = 1e-6\n    high = 5.0\n    \n    # Check if price achievable within bounds\n    p_low = bs_price(S, K, T, r, q, low, option_type)\n    p_high = bs_price(S, K, T, r, q, high, option_type)\n    \n    if market_price < p_low:\n        return {\"iv\": low, \"status\": \"clipped_low\"} # Vol is < 1e-6\n    if market_price > p_high:\n        return {\"iv\": high, \"status\": \"clipped_high\"} # Vol is > 5.0\n        \n    # Bisect\n    inv_iter = 0\n    max_iter = 100\n    tol = 1e-7\n    \n    while inv_iter < max_iter:\n        mid = (low + high) / 2.0\n        p_mid = bs_price(S, K, T, r, q, mid, option_type)\n        \n        diff = p_mid - market_price\n        \n        if abs(diff) < tol:\n            return {\"iv\": mid, \"status\": \"ok\", \"iterations\": inv_iter}\n        \n        if diff > 0:\n            # Price (almost always) monotonic in Vol. If p_mid too high, reduce vol.\n            high = mid\n        else:\n            low = mid\n            \n        inv_iter += 1\n        \n    return {\"iv\": mid, \"status\": \"converged_tol\", \"iterations\": inv_iter}\n",
  "heatmap.py": "from .core import bs_price\nfrom .greeks import bs_greeks\nimport math\n\ndef linspace(start, end, steps):\n    if steps <= 1:\n        # If range is single point or steps=1\n        return [start]\n    step = (end - start) / (steps - 1)\n    return [start + i * step for i in range(steps)]\n\ndef compute_metric_value(metric, S, K, T, r, q, sigma, option_type, base_price=None):\n    if metric == \"Call Price\":\n        return bs_price(S, K, T, r, q, sigma, \"call\")\n    elif metric == \"Put Price\":\n        return bs_price(S, K, T, r, q, sigma, \"put\")\n    elif metric == \"PnL\":\n        # PnL requires comparison to a base price.\n        # If metric is PnL, we usually mean [Current Option Price] - [Baseline Option Price]\n        # Base Price must be passed in.\n        curr = bs_price(S, K, T, r, q, sigma, option_type)\n        if base_price is not None:\n            return curr - base_price\n        return 0.0\n\n    # Greeks\n    g = bs_greeks(S, K, T, r, q, sigma, option_type)\n    \n    if metric == \"Delta\": return g[\"delta\"]\n    if metric == \"Gamma\": return g[\"gamma\"]\n    if metric == \"Vega\": return g[\"vega\"] / 100.0   # Display per 1% vol\n    if metric == \"Theta\": return g[\"theta\"] / 365.0 # Display per day\n    if metric == \"Rho\": return g[\"rho\"] / 100.0     # Display per 1% rate\n    \n    # IV in heatmap?\n    if metric == \"IV\":\n        # If we are plotting IV, we usually mean we are viewing the Vol Surface if sigma is not constant?\n        # But here sigma is an input. If X/Y is not sigma, IV is just constant sigma input.\n        # If X is sigma, then IV = X.\n        # Simple identity for this lab setup.\n        return sigma\n\n    return 0.0\n\ndef generate_heatmap_grid(params, metric, x_var, y_var, x_range, y_range):\n    \"\"\"\n    params: dict with S, K, T, r, q, sigma, option_type\n    x_range, y_range: {min, max, steps}\n    \"\"\"\n    x_steps = int(x_range['steps'])\n    y_steps = int(y_range['steps'])\n    \n    # Safety Cap\n    MAX_CELLS = 6400\n    if x_steps * y_steps > MAX_CELLS:\n        ratio = x_steps / y_steps\n        new_y = int(math.sqrt(MAX_CELLS / ratio))\n        new_x = int(ratio * new_y)\n        x_steps = max(10, new_x)\n        y_steps = max(10, new_y)\n        \n    x_vals = linspace(x_range['min'], x_range['max'], x_steps)\n    y_vals = linspace(y_range['min'], y_range['max'], y_steps)\n    \n    # If metric is PnL, calculate base price once\n    base_price = None\n    if metric == \"PnL\":\n        base_price = bs_price(params['S'], params['K'], params['T'], params['r'], params['q'], params['sigma'], params['option_type'])\n    \n    z_matrix = []\n    \n    # Pre-copy dict to avoid re-creation overhead in loop (shallow copy ok for primitives)\n    p = params.copy()\n    \n    for y in y_vals:\n        row = []\n        p[y_var] = y\n        for x in x_vals:\n            p[x_var] = x\n            \n            # Compute\n            val = compute_metric_value(metric, p['S'], p['K'], p['T'], p['r'], p['q'], p['sigma'], p['option_type'], base_price)\n            row.append(val)\n        z_matrix.append(row)\n        \n    return {\n        \"xValues\": x_vals,\n        \"yValues\": y_vals,\n        \"zMatrix\": z_matrix\n    }\n",
  "api.py": "import json\nfrom .core import bs_price\nfrom .greeks import bs_greeks\nfrom .iv import implied_volatility\nfrom .heatmap import generate_heatmap_grid\n\ndef validate_positive(val, name, allow_zero=False):\n    if allow_zero:\n        if val < 0: return 0.0\n    else:\n        if val <= 1e-9: return 1e-9\n    return val\n\ndef run_compute(payload_json: str) -> str:\n    try:\n        data = json.loads(payload_json)\n        \n        tickers = data.get(\"tickers\", [\"T1\", \"T2\", \"T3\"])\n        params_list = data.get(\"params\", [])\n        heatmap_req = data.get(\"heatmap\", None)\n        \n        results = {\n            \"tickers\": []\n        }\n        \n        # 1. Compute Output Cards\n        for i, p in enumerate(params_list):\n            try:\n                # Validation\n                S = validate_positive(p.get(\"S\", 100), \"S\")\n                K = validate_positive(p.get(\"K\", 100), \"K\")\n                T = validate_positive(p.get(\"T\", 1.0), \"T\", allow_zero=True)\n                sigma = validate_positive(p.get(\"sigma\", 0.2), \"sigma\")\n                r = p.get(\"r\", 0.05)\n                q = p.get(\"q\", 0.0)\n                opt_type = p.get(\"option_type\", \"call\")\n                \n                # Prices\n                call = bs_price(S, K, T, r, q, sigma, \"call\")\n                put = bs_price(S, K, T, r, q, sigma, \"put\")\n                \n                # Greeks\n                greeks = bs_greeks(S, K, T, r, q, sigma, opt_type)\n                \n                # IV if market price provided\n                iv_res = None\n                mkt_price = p.get(\"market_price\", None)\n                if mkt_price is not None:\n                    iv_res = implied_volatility(mkt_price, S, K, T, r, q, opt_type)\n                    \n                results[\"tickers\"].append({\n                    \"ticker\": tickers[i] if i < len(tickers) else f\"T{i+1}\",\n                    \"call\": call,\n                    \"put\": put,\n                    \"delta\": greeks[\"delta\"],\n                    \"gamma\": greeks[\"gamma\"],\n                    \"vega\": greeks[\"vega\"] / 100.0, # Scale for display\n                    \"theta\": greeks[\"theta\"] / 365.0, # Scale to Daily\n                    \"rho\": greeks[\"rho\"] / 100.0, # Scale\n                    \"iv\": iv_res[\"iv\"] if iv_res else None,\n                    \"iv_status\": iv_res[\"status\"] if iv_res else None\n                })\n            except Exception as e:\n                # Per ticker error fallback\n                results[\"tickers\"].append({\n                    \"ticker\": tickers[i] if i < len(tickers) else f\"T{i+1}\",\n                    \"error\": str(e),\n                    # Zero defaults to not break UI typings\n                    \"call\": 0, \"put\": 0, \"delta\": 0, \"gamma\": 0, \"vega\": 0, \"theta\": 0, \"rho\": 0\n                })\n            \n        # 2. Compute Heatmap (for each ticker)\n        if heatmap_req:\n            metric = heatmap_req.get(\"metric\", \"Call Price\")\n            x_var = heatmap_req.get(\"xVar\", \"S\")\n            y_var = heatmap_req.get(\"yVar\", \"sigma\")\n            x_range = heatmap_req.get(\"xRange\", {\"min\": 50, \"max\": 150, \"steps\": 20})\n            y_range = heatmap_req.get(\"yRange\", {\"min\": 0.1, \"max\": 0.5, \"steps\": 20})\n            \n            grids = []\n            for i, p in enumerate(params_list):\n                try:\n                    grid_params = {\n                        \"S\": validate_positive(p.get(\"S\", 100), \"S\"),\n                        \"K\": validate_positive(p.get(\"K\", 100), \"K\"),\n                        \"T\": validate_positive(p.get(\"T\", 1.0), \"T\", allow_zero=True),\n                        \"r\": p.get(\"r\", 0.05),\n                        \"q\": p.get(\"q\", 0.0),\n                        \"sigma\": validate_positive(p.get(\"sigma\", 0.2), \"sigma\"),\n                        \"option_type\": p.get(\"option_type\", \"call\")\n                    }\n                    \n                    grid = generate_heatmap_grid(grid_params, metric, x_var, y_var, x_range, y_range)\n                    grids.append(grid)\n                except Exception as e:\n                     # Add empty grid or error indicator\n                     grids.append({\"error\": str(e), \"xValues\": [], \"yValues\": [], \"zMatrix\": []})\n                \n            results[\"heatmap\"] = grids\n            \n        return json.dumps(results)\n        \n    except Exception as e:\n        return json.dumps({\"error\": f\"Top level error: {str(e)}\"})\n",
  "__init__.py": ""
};