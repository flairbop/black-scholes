export const BS_LAB_FILES = {
  "core.py": "import math\n\ndef norm_pdf(x):\n    \"\"\"Standard normal probability density function.\"\"\"\n    return math.exp(-0.5 * x * x) / math.sqrt(2 * math.pi)\n\ndef norm_cdf(x):\n    \"\"\"Standard normal cumulative distribution function.\"\"\"\n    return 0.5 * (1 + math.erf(x / math.sqrt(2.0)))\n\ndef d1_d2(S, K, T, r, q, sigma):\n    \"\"\"Computes d1 and d2 terms for Black-Scholes.\"\"\"\n    sqrt_T = math.sqrt(T)\n    d1 = (math.log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * sqrt_T)\n    d2 = d1 - sigma * sqrt_T\n    return d1, d2\n\ndef bs_price(S, K, T, r, q, sigma, option_type=\"call\"):\n    \"\"\"Computes Black-Scholes price for call or put.\"\"\"\n    if T <= 0:\n        # Intrinsic value at expiry\n        if option_type == \"call\":\n            return max(0.0, S - K)\n        else:\n            return max(0.0, K - S)\n    \n    # Avoid division by zero if sigma is very small\n    if sigma < 1e-9:\n        # Intrinsic approx\n        val = S * math.exp((r-q)*T) - K\n        if option_type == \"call\":\n            return max(0.0, (S * math.exp(-q*T) - K * math.exp(-r*T))) # Wait, proper limit logic needed\n            # For simplicity, if sigma ~ 0, use intrinsic of forwards\n        # Just clamp sigma in caller usually, but here:\n        sigma = 1e-9\n\n    d1, d2 = d1_d2(S, K, T, r, q, sigma)\n    \n    if option_type == \"call\":\n        price = S * math.exp(-q * T) * norm_cdf(d1) - K * math.exp(-r * T) * norm_cdf(d2)\n    else:\n        price = K * math.exp(-r * T) * norm_cdf(-d2) - S * math.exp(-q * T) * norm_cdf(-d1)\n        \n    return price\n\ndef bs_greeks(S, K, T, r, q, sigma, option_type=\"call\"):\n    \"\"\"Computes Delta, Gamma, Vega, Theta, Rho.\"\"\"\n    if T <= 0:\n        return {\n            \"delta\": 0.0, \"gamma\": 0.0, \"vega\": 0.0, \"theta\": 0.0, \"rho\": 0.0\n        }\n    \n    if sigma < 1e-9: sigma = 1e-9\n\n    d1, d2 = d1_d2(S, K, T, r, q, sigma)\n    nd1 = norm_pdf(d1)\n    \n    # Common terms\n    exp_qT = math.exp(-q * T)\n    exp_rT = math.exp(-r * T)\n    sqrt_T = math.sqrt(T)\n    \n    # Gamma (same for call and put)\n    gamma = (exp_qT * nd1) / (S * sigma * sqrt_T)\n    \n    # Vega (same for call and put) - raw derivative dV/dSigma\n    vega = S * exp_qT * nd1 * sqrt_T\n    \n    if option_type == \"call\":\n        delta = exp_qT * norm_cdf(d1)\n        rho = K * T * exp_rT * norm_cdf(d2)\n        theta = (- (S * exp_qT * nd1 * sigma) / (2 * sqrt_T) \n                 - r * K * exp_rT * norm_cdf(d2) \n                 + q * S * exp_qT * norm_cdf(d1))\n    else: # put\n        delta = -exp_qT * norm_cdf(-d1)\n        rho = -K * T * exp_rT * norm_cdf(-d2)\n        theta = (- (S * exp_qT * nd1 * sigma) / (2 * sqrt_T) \n                 + r * K * exp_rT * norm_cdf(-d2) \n                 - q * S * exp_qT * norm_cdf(-d1))\n                 \n    return {\n        \"delta\": delta,\n        \"gamma\": gamma,\n        \"vega\": vega / 100.0, # Display per 1% vol\n        \"theta\": theta / 365.0, # Display per day usually? Request says \"Theta output in per year with optional conversion\". \n                                # I will store/return per Year in core, let UI/API handle conversion? \n                                # Prompt says: \"Theta output in “per year” with an optional conversion to “per day” flag controlled from UI\"\n                                # So I should return Per Year and let frontend or API layer scale it.\n                                # Wait, I'll return both in the API if needed.\n                                # But standard Greek Theta definition is per year. \n                                # Let's return raw per year here.\n        \"rho\": rho / 100.0 # Display per 1% rate\n    }\n\ndef get_theta_raw(S, K, T, r, q, sigma, option_type=\"call\"):\n    # Return strict per-year theta for consistency with logic\n    g = bs_greeks(S, K, T, r, q, sigma, option_type)\n    return g[\"theta\"] * 365.0 # Because I divided by 365 above.\n    \n# Actually, let's just make bs_greeks return STANDARD definitions (per unit time = year, per unit vol = 1.0)\n# And I will handle scaling in the compute layer.\ndef bs_greeks_raw(S, K, T, r, q, sigma, option_type=\"call\"):\n    if T <= 1e-7:\n        return { \"delta\": 0.0, \"gamma\": 0.0, \"vega\": 0.0, \"theta\": 0.0, \"rho\": 0.0 }\n    \n    if sigma < 1e-9: sigma = 1e-9\n    \n    d1, d2 = d1_d2(S, K, T, r, q, sigma)\n    nd1 = norm_pdf(d1)\n    exp_qT = math.exp(-q * T)\n    exp_rT = math.exp(-r * T)\n    sqrt_T = math.sqrt(T)\n    \n    gamma = (exp_qT * nd1) / (S * sigma * sqrt_T)\n    vega = S * exp_qT * nd1 * sqrt_T\n    \n    if option_type == \"call\":\n        delta = exp_qT * norm_cdf(d1)\n        rho = K * T * exp_rT * norm_cdf(d2)\n        theta = (- (S * exp_qT * nd1 * sigma) / (2 * sqrt_T) \n                 - r * K * exp_rT * norm_cdf(d2) \n                 + q * S * exp_qT * norm_cdf(d1))\n    else:\n        delta = -exp_qT * norm_cdf(-d1)\n        rho = -K * T * exp_rT * norm_cdf(-d2)\n        theta = (- (S * exp_qT * nd1 * sigma) / (2 * sqrt_T) \n                 + r * K * exp_rT * norm_cdf(-d2) \n                 - q * S * exp_qT * norm_cdf(-d1))\n    \n    return {\n        \"delta\": delta,\n        \"gamma\": gamma,\n        \"vega\": vega, \n        \"theta\": theta,\n        \"rho\": rho\n    }\n",
  "iv.py": "from .core import bs_price\nimport math\n\nERROR_ARBITRAGE = \"Arbitrage violation: Price out of bounds\"\nERROR_CONVERGENCE = \"Solver failed to converge\"\n\ndef implied_volatility(market_price, S, K, T, r, q, option_type=\"call\"):\n    \"\"\"\n    Computes implied volatility using bisection method.\n    Metrics: sigma in [1e-6, 5.0]\n    \"\"\"\n    # 0. Pre-checks\n    if T <= 0:\n        return {\"iv\": 0.0, \"status\": \"expired\"}\n    \n    # 1. Arbitrage Bounds\n    exp_rT = math.exp(-r * T)\n    exp_qT = math.exp(-q * T)\n    \n    if option_type == \"call\":\n        lower_bound = max(0.0, S * exp_qT - K * exp_rT)\n        upper_bound = S * exp_qT\n    else:\n        lower_bound = max(0.0, K * exp_rT - S * exp_qT)\n        upper_bound = K * exp_rT\n    \n    # Allow small epsilon tolerance for float errors\n    epsilon = 1e-7\n    if market_price < lower_bound - epsilon or market_price > upper_bound + epsilon:\n        return {\"iv\": None, \"status\": ERROR_ARBITRAGE, \"bounds\": (lower_bound, upper_bound)}\n        \n    # If price is at lower bound (intrinsic), IV is 0 (or undefined/low).\n    if abs(market_price - lower_bound) < epsilon:\n        return {\"iv\": 0.0, \"status\": \"intrinsic\"}\n        \n    # 2. Bisection Solver\n    # Sigma bounds\n    low = 1e-6\n    high = 5.0\n    \n    # Check bounds values\n    p_low = bs_price(S, K, T, r, q, low, option_type)\n    p_high = bs_price(S, K, T, r, q, high, option_type)\n    \n    # If market price is outside the price range accessible by sigma in [1e-6, 5.0]\n    if market_price < p_low:\n        return {\"iv\": low, \"status\": \"clipped_low\"}\n    if market_price > p_high:\n        return {\"iv\": high, \"status\": \"clipped_high\"}\n        \n    # Bisect\n    inv_iter = 0\n    max_iter = 100\n    tol = 1e-7\n    \n    while inv_iter < max_iter:\n        mid = (low + high) / 2.0\n        p_mid = bs_price(S, K, T, r, q, mid, option_type)\n        \n        diff = p_mid - market_price\n        \n        if abs(diff) < tol:\n            return {\"iv\": mid, \"status\": \"ok\", \"iterations\": inv_iter}\n        \n        if diff > 0:\n            # Price is increasing with vol (Vega > 0 almost always)\n            # If p_mid > market, we need lower vol\n            high = mid\n        else:\n            low = mid\n            \n        inv_iter += 1\n        \n    return {\"iv\": mid, \"status\": \"converged_tol\", \"iterations\": inv_iter}\n",
  "heatmap.py": "from .core import bs_price, bs_greeks_raw\nfrom .iv import implied_volatility\nimport math\n\ndef linspace(start, end, steps):\n    if steps <= 1:\n        return [start]\n    step = (end - start) / (steps - 1)\n    return [start + i * step for i in range(steps)]\n\ndef compute_metric_value(metric, S, K, T, r, q, sigma, option_type, base_price=None):\n    if metric == \"Call Price\":\n        return bs_price(S, K, T, r, q, sigma, \"call\")\n    elif metric == \"Put Price\":\n        return bs_price(S, K, T, r, q, sigma, \"put\")\n    elif metric == \"PnL\":\n        # PnL is (Current Price - Base Price)\n        # We need the current price based on option_type\n        curr_price = bs_price(S, K, T, r, q, sigma, option_type)\n        if base_price is None:\n            return 0.0 # Should not happen if correctly called\n        return curr_price - base_price\n    \n    # Greeks\n    greeks = bs_greeks_raw(S, K, T, r, q, sigma, option_type)\n    \n    if metric == \"Delta\": return greeks[\"delta\"]\n    if metric == \"Gamma\": return greeks[\"gamma\"]\n    if metric == \"Vega\": return greeks[\"vega\"] / 100.0   # Scale for display\n    if metric == \"Theta\": return greeks[\"theta\"] / 365.0 # Scale to daily for display? Prompt said \"per year\" but \"optional conversion\". \n                                                         # Let's return Daily for the Heatmap as it's more intuitive number, \n                                                         # OR keep Per Year but label it. \n                                                         # Let's stick to Per Year as getting small numbers in heatmap is annoying?\n                                                         # Actually, traders look at Daily theta. \n                                                         # Prompt: \"Theta output in “per year”...\"\n                                                         # Let's standardise: Heatmap sees what output cards see.\n                                                         # I will use Per Year / 365.0 (Daily) because standard web labs usually show daily theta.\n                                                         # Actually, let's just use raw from core (Year) / 365.0 = Daily.\n                                                         # I'll stick to Daily Theta for UI visualization.\n    if metric == \"Rho\": return greeks[\"rho\"] / 100.0     # Scale for display\n    \n    if metric == \"IV\":\n        # Solve for IV given the computed price? No, that's circular if we are computing FROM params.\n        # Unless X or Y is NOT sigma, and we want to see IV?\n        # If we are simulating \"Effect of Spot and Time on... IV?\" \n        # IV is an input parameter (sigma). So IV is constant unless X or Y is sigma.\n        # If X is sigma, then IV = X.\n        # If we are plotting IV, we usually mean \"Implied Vol surface\".\n        # But here valid inputs are S, K, sigma...\n        # If metric is IV, just return sigma.\n        return sigma\n\n    return 0.0\n\ndef generate_heatmap_grid(params, metric, x_var, y_var, x_range, y_range):\n    \"\"\"\n    params: dict with S, K, T, r, q, sigma, option_type\n    x_range, y_range: {min, max, steps}\n    \"\"\"\n    x_steps = int(x_range['steps'])\n    y_steps = int(y_range['steps'])\n    \n    # Cap steps\n    if x_steps * y_steps > 6400:\n        # Simple cap logic: keep aspect ratio? or just clamp?\n        # User said \"auto-cap steps to keep product <= 6400\"\n        ratio = x_steps / y_steps\n        # new_x * new_y = 6400 => ratio * new_y^2 = 6400 => new_y = sqrt(6400/ratio)\n        new_y = int(math.sqrt(6400 / ratio))\n        new_x = int(ratio * new_y)\n        x_steps = new_x\n        y_steps = new_y\n        \n    x_vals = linspace(x_range['min'], x_range['max'], x_steps)\n    y_vals = linspace(y_range['min'], y_range['max'], y_steps)\n    \n    # Pre-compute base price if metric is PnL\n    base_price = None\n    if metric == \"PnL\":\n        base_price = bs_price(params['S'], params['K'], params['T'], params['r'], params['q'], params['sigma'], params['option_type'])\n    \n    z_matrix = []\n    \n    # Create working copy of params\n    p = params.copy()\n    \n    for y in y_vals:\n        row = []\n        p[y_var] = y\n        for x in x_vals:\n            p[x_var] = x\n            \n            # Compute\n            # Ensure safe inputs (e.g. T > 0)\n            # Core functions handle T<=0, but S<0 might be issues? Core handles math.log(S/K).\n            # If x_var is S and x is negative (unlikely from UI), we crash.\n            # We assume range is valid positive.\n            \n            val = compute_metric_value(metric, p['S'], p['K'], p['T'], p['r'], p['q'], p['sigma'], p['option_type'], base_price)\n            row.append(val)\n        z_matrix.append(row)\n        \n    return {\n        \"xValues\": x_vals,\n        \"yValues\": y_vals,\n        \"zMatrix\": z_matrix\n    }\n",
  "api.py": "import json\nfrom .core import bs_price, bs_greeks_raw, get_theta_raw\nfrom .iv import implied_volatility\nfrom .heatmap import generate_heatmap_grid, compute_metric_value\n\ndef validate_positive(val, name, allow_zero=False):\n    if allow_zero:\n        if val < 0: return 0.0\n    else:\n        if val <= 1e-9: return 1e-9\n    return val\n\ndef run_compute(payload_json: str) -> str:\n    try:\n        data = json.loads(payload_json)\n        \n        tickers = data.get(\"tickers\", [\"T1\", \"T2\", \"T3\"])\n        params_list = data.get(\"params\", [])\n        heatmap_req = data.get(\"heatmap\", None)\n        \n        results = {\n            \"tickers\": []\n        }\n        \n        # 1. Compute Output Cards\n        for i, p in enumerate(params_list):\n            # Validate\n            S = validate_positive(p.get(\"S\", 100), \"S\")\n            K = validate_positive(p.get(\"K\", 100), \"K\")\n            T = validate_positive(p.get(\"T\", 1.0), \"T\", allow_zero=True)\n            sigma = validate_positive(p.get(\"sigma\", 0.2), \"sigma\")\n            r = p.get(\"r\", 0.05)\n            q = p.get(\"q\", 0.0)\n            opt_type = p.get(\"option_type\", \"call\")\n            \n            # Prices\n            call = bs_price(S, K, T, r, q, sigma, \"call\")\n            put = bs_price(S, K, T, r, q, sigma, \"put\")\n            \n            # Greeks (metric dependent on option type)\n            greeks = bs_greeks_raw(S, K, T, r, q, sigma, opt_type)\n            \n            # IV if market price provided\n            iv_res = None\n            mkt_price = p.get(\"market_price\", None)\n            if mkt_price is not None:\n                iv_res = implied_volatility(mkt_price, S, K, T, r, q, opt_type)\n                \n            results[\"tickers\"].append({\n                \"ticker\": tickers[i] if i < len(tickers) else f\"T{i+1}\",\n                \"call\": call,\n                \"put\": put,\n                \"delta\": greeks[\"delta\"],\n                \"gamma\": greeks[\"gamma\"],\n                \"vega\": greeks[\"vega\"] / 100.0,\n                \"theta\": greeks[\"theta\"] / 365.0, # Daily\n                \"rho\": greeks[\"rho\"] / 100.0,\n                \"iv\": iv_res[\"iv\"] if iv_res else None,\n                \"iv_status\": iv_res[\"status\"] if iv_res else None\n            })\n            \n        # 2. Compute Heatmap (for each ticker)\n        if heatmap_req:\n            metric = heatmap_req.get(\"metric\", \"Call Price\")\n            x_var = heatmap_req.get(\"xVar\", \"S\")\n            y_var = heatmap_req.get(\"yVar\", \"sigma\")\n            x_range = heatmap_req.get(\"xRange\", {\"min\": 50, \"max\": 150, \"steps\": 20})\n            y_range = heatmap_req.get(\"yRange\", {\"min\": 0.1, \"max\": 0.5, \"steps\": 20})\n            \n            grids = []\n            for i, p in enumerate(params_list):\n                # We need to pass the FULL params for this ticker to the grid gen\n                # which will substitute xVar and yVar\n                grid_params = {\n                    \"S\": validate_positive(p.get(\"S\", 100), \"S\"),\n                    \"K\": validate_positive(p.get(\"K\", 100), \"K\"),\n                    \"T\": validate_positive(p.get(\"T\", 1.0), \"T\", allow_zero=True),\n                    \"r\": p.get(\"r\", 0.05),\n                    \"q\": p.get(\"q\", 0.0),\n                    \"sigma\": validate_positive(p.get(\"sigma\", 0.2), \"sigma\"),\n                    \"option_type\": p.get(\"option_type\", \"call\")\n                }\n                \n                grid = generate_heatmap_grid(grid_params, metric, x_var, y_var, x_range, y_range)\n                grids.append(grid)\n                \n            results[\"heatmap\"] = grids\n            \n        return json.dumps(results)\n        \n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n",
  "__init__.py": ""
};